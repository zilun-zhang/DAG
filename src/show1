
import os, json, pickle, gzip
from pathlib import Path
from typing import Dict, Any, Tuple, List
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from networkx.readwrite import json_graph

# ======= 写死你的图路径（可多个）======
PATHS: List[str] = [
    r"E:\DAG\src\generated5\gen_like_1755562832.gpickle", 
    r"E:\DAG\data\gpickle1\Tau_4_Tau_0.gpickle", 
]
SAVE_PNG = False   # True 则保存 PNG 到同目录，后缀 _vis.png
# ====================================

TIME_KEYS = ["critical_time", "time", "weight", "t", "C", "label"]


def get_edge_time(d: dict):
    for k in TIME_KEYS:
        if k in d:
            return float(d[k])
    return None

def normalize_edge_time_key(G: nx.DiGraph) -> int:
    changed = 0
    for u, v, d in G.edges(data=True):
        if "critical_time" not in d:
            t = get_edge_time(d)
            if t is not None:
                d["critical_time"] = t
                changed += 1
    return changed

def _read_gpickle_robust(path: str):
    try:
        from networkx.readwrite.gpickle import read_gpickle as _rg
        return _rg(path)
    except Exception:
        opener = gzip.open if path.endswith(".gz") else open
        with opener(path, "rb") as f:
            return pickle.load(f)

def load_graph(path: str) -> nx.DiGraph:
    p = Path(path); ext = p.suffix.lower()
    if ext in [".gpickle", ".gz"]:
        G = _read_gpickle_robust(str(p))
    elif ext == ".json":
        data = json.loads(p.read_text(encoding="utf-8"))
        G = json_graph.node_link_graph(data, directed=True, multigraph=False)
    else:
        raise ValueError(f"Unsupported file type: {ext}")
    if not isinstance(G, nx.DiGraph):
        G = G.to_directed()
    normalize_edge_time_key(G)
    return G

def _ensure_layout_attrs(G: nx.DiGraph) -> None:
    if any("layer" not in G.nodes[n] for n in G.nodes):
        topo = list(nx.topological_sort(G))
        dist = {n: 0 for n in topo}
        for u in topo:
            for v in G.successors(u):
                dist[v] = max(dist[v], dist[u] + 1)
        for n in G.nodes:
            G.nodes[n]["layer"] = dist[n]
    if any("pos" not in G.nodes[n] for n in G.nodes):
        layers = {}
        for n, d in G.nodes(data=True):
            layers.setdefault(d.get("layer", 0), []).append(n)
        for _, nodes in layers.items():
            for i, n in enumerate(sorted(nodes)):
                G.nodes[n]["pos"] = i

def _layered_positions(G: nx.DiGraph) -> Dict[Any, Tuple[float, float]]:
    return {n: (d["layer"], -float(d["pos"])) for n, d in G.nodes(data=True)}

def draw_graph(G: nx.DiGraph, title: str = "", show_edge_time: bool = True) -> None:
    _ensure_layout_attrs(G)
    pos = _layered_positions(G)
    plt.figure()
    nx.draw(G, pos, with_labels=True, arrows=True)
    if show_edge_time:
        edge_labels = {(u, v): f"{float(d['critical_time']):.2f}"
                       for u, v, d in G.edges(data=True) if "critical_time" in d}
        nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=7)
    if title:
        plt.title(title)

def print_time_stats(G: nx.DiGraph, name: str = ""):
    ts = [d.get("critical_time") for _, _, d in G.edges(data=True) if "critical_time" in d]
    if ts:
        print(f"[{name}] edges={len(ts)} | total={np.sum(ts):.3f} | "
              f"min={np.min(ts):.3f} | max={np.max(ts):.3f} | mean={np.mean(ts):.3f}")
    else:
        print(f"[{name}] 这个图的边上没有可识别的时间属性（critical_time/time/weight/C/t）。")

if __name__ == "__main__":
    if not PATHS:
        print("PATHS 为空，请先在文件顶部填写你的图路径。"); raise SystemExit(1)
    for p in PATHS:
        G = load_graph(p)
        name = os.path.basename(p)
        draw_graph(G, title=name, show_edge_time=True)
        print_time_stats(G, name=name)
        if SAVE_PNG:
            out = os.path.splitext(p)[0] + "_vis.png"
            plt.savefig(out, dpi=150, bbox_inches="tight"); plt.close()
            print(f"Saved: {out}")
    if not SAVE_PNG:
        plt.show()
